\section{Grundlegende Definitionen und Algorithmen}
\label{section:basics}

In diesem Kapitel definieren wir die für unsere Zwecke relevanten Begriffe im Kontext der Clusteranalyse und führen die
wichtigen grundlegenden Algorithmen ein, deren Ideen für uns im Folgenden noch von Bedeutung sein werden. Wir gehen dabei
nach Themengebieten geordnet vor: In Abschnitt~\ref{subsection:basics:clustering} skizzieren wir kurz das
Themengebiet der Clusteranalyse, definieren die üblichen Zielfunktionen und stellen zwei bedeutende Algorithmen vor.
Abschnitt~\ref{subsection:basics:graphs} führt kurz in die Graphentheorie sowie die Clusteranalyse von Graphen ein. In diesem
Abschnitt werden wir zudem die von der klassischen Clusteranalyse sehr unterschiedlichen Optimierungskritierien für die
Clusteranalyse von Graphen herausstellen. Schließlich fassen wir in Abschnitt~\ref{subsection:basics:kernel-spectral} die
wichtigsten Methoden und Algorithmen aus dem Bereich der spektralen Clusteranalyse zusammen und stellen zudem die wesentlichen
Konzepte von Kernel-Methoden vor.

\subsection{Clustering und \texorpdfstring{$k$}{k}-means}
\label{subsection:basics:clustering}

Clusteranalyse oder "`Clustering"' beschäftigt sich mit der Einteilung von Objekten in Gruppen ("`Cluster"'), sodass
sich die Objekte innerhalb eines Clusters gemäß eines bestimmten Optimierungskriteriums ähnlich sind und von Objekten eines
anderen Clusters unterscheiden. Es existieren zahlreiche grundsätzlich verschiedene Ansätze, Clusteringprobleme zu lösen.
Wir beschränken uns in dieser Arbeit auf \emph{partitionierende} Clusteringprobleme und -verfahren. Bei diesen
soll eine Menge von $d$-dimensionalen Punkten, welche der erste Teil der Eingabe ist, gemäß einer Cluster-Zielfunktion möglichst
optimal in genau $k$ Cluster unterteilt werden, wobei $k$ der ganzzahlige zweite Teil der Eingabe ist.

Für die Zielfunktion, welche die Nähe oder Ferne von Punkten zueinander quantifiziert, sind bei Eingabepunkten aus
$\Rd$ Metriken naheliegend. Intuitiv ist dabei die euklidische Distanz, welche als Zielfunktion für die beiden bekanntesten
Clustering-Problemstellungen dient.

\begin{definition}[$k$-median und $k$-means]
Sei $P \subset \Rd$ und $k \in \mathbb{N}^{+}$. Das $k$-median-Problem besteht darin, eine Menge von $k$ (Cluster-)\emph{Zentren}
$C = \{ c_1, \dots, c_k \}$ mit $c_i \in \Rd$ zu finden, sodass der folgende Term minimal wird:
\[ \sum_{p \in P} \min_{c_i \in C} \Euclid{p}{c} \]
Das $k$-means-Problem unterscheidet sich nur darin, dass bei diesem die Summe der \emph{quadrierten} euklidischen Distanzen
zum jeweils nächstgelegenen Zentrum minimiert werden soll, das heißt, dass der folgende Term minimiert werden soll:
\[ \sum_{p \in P} \min_{c_i \in C} \EuclidSquared{p}{c} \]
Beim \emph{gewichteten} $k$-means-Problem werden den Eingabepunkten zusätzlich mit einer Funktion $w : P \rightarrow \mathbb{R}$
Gewichte zugewiesen. Die zu minimierende Zielfunktion lautet dann entsprechend
\[ \sum_{p \in P} \min_{c_i \in C} w(p) \EuclidSquared{p}{c} \]
\end{definition}
Sowohl das $k$-Median-Problem~\cite{MegiddoS84} als auch das $k$-means-Problem~\cite{AloiseDHP09} sind optimal NP-schwer lösbar.
Typischerweise werden zur Lösung daher approximative oder heuristische Algorithmen eingesetzt. Die bekannteste und bis
heute sehr erfolgreiche Heuristik für das $k$-means-Problem ist der Algorithmus von Lloyd~\cite{Lloyd82}.
Der Algorithmus wählt initial $k$ zufällige Punkte aus der Eingabemenge oder sogar beliebige Punkte aus $\Rd$ als initiale
Clusterzentren. Anschließend wird jedem Punkt das am nächsten gelegene Zentrum zugewiesen. Dadurch entstehen die initialen Cluster
mit ihren jeweiligen Zentren. Im zweiten Schritt wird das neue Zentrum eines jeden Clusters als der geometrische Zentroid
des Clusters gewählt. Die Zuweisung von Punkten zum nächstgelegenen Cluster und die Neuberechnung der neuen Zentren werden
solange alterniert, bis die Lösung konvergiert, also wenn sich die Zuordnungen der Punkte nicht mehr ändern. In der Praxis
wird gelegentlich auch nach einer festen Anzahl von Iterationen terminiert.

\begin{algorithm}[H]
\label{algo:lloyd}
\caption{Algorithmus von Lloyd}
	% Optionen
	\DontPrintSemicolon
	\SetKwInOut{Input}{Eingabe:}
	\SetKwInOut{Output}{Ausgabe:}
	
	% Input/Output
	\Input{$P \subseteq \Rd, k \in \mathbb{N}^{+}$}
	\Output{$k$-means-Clustering von $P$}
	\BlankLine
	
	% Algo
	Wähle zufällig $k$ Zentren $c_1^{(0)}, \dots, c_k^{(0)}$ aus $P$ oder $\Rd$\;
	$S_i^{(0)} \leftarrow \{ p \in P : \EuclidSquared{p}{c_i^{(0)}} \leq \EuclidSquared{p}{c_{i'}^{(0)}} \, \forall \, i' \in \{ 1, \dots, k \} \}$\;
	\Repeat{$S_i^{(t)} = S_i^{(t-1)}$}{
		$c_i^{(t)} \leftarrow \frac{1}{|S_i^{(t-1)}|} \sum_{p_j \in S_i^{(t-1)}} p_j $\;
		$S_i^{(t)} \leftarrow \{ p \in P : \EuclidSquared{p}{c_i^{(t)}} \leq \EuclidSquared{p}{c_{i'}^{(t)}} \, \forall \, i' \in \{ 1, \dots, k \} \}$\;
	}
\end{algorithm}

Die asymptotische Laufzeit des Algorithmus beträgt $\BigO{nkdi}$, wobei $i$ die Anzahl an durchgeführten Iterationen ist.
Wenn der Algorithmus konvergiert und nicht durch eine feste Anzahl von Iterationen terminiert wird, wurde ein lokales
Optimum gefunden, welches jedoch im Allgemeinen kein globales Optimum oder eine Approximation eines globalen Optimums ist.
Die Güte des berechneten Clusterings hängt maßgeblich von der initialen Wahl der Cluster ab. Der Algorithmus
\kmpp~\cite{ArthurV07} setzt genau an dieser Stelle an: er berechnet auf einfache, aber dennoch geschickte Art und Weise
die initialen Cluster und führt anschließend mit diesen die übrigen Schritte von Lloyds Algorithmus durch.
Der Algorithmus wählt zunächst ein einzelnes Clusterzentrum $c_1$ zufällig gleichverteilt aus der Eingabe-Punktmenge $P$ und
wählt alle weiteren Clusterzentren sukzessive nach der folgenden Vorschrift, bis insgesamt $k$ Zentren gewählt wurden.
Im Weiteren bezeichnen wir mit $D(x)$ für einen Punkt $x$ aus der Eingabe-Punktmenge $P$ die geringste Distanz von $x$ zum
nächstgelegenen bereits gewählten Zentrum. In jeder Iteration wird als nächstes Zentrum $c_i$ der Punkt
$x' \in P \setminus \{ c_1, \dots, c_{i-1} \}$ mit Wahrscheinlichkeit $\frac{D(x')^2}{\sum_{x \in P} D(x)}$ gewählt.

\begin{algorithm}[H]
\label{algo:kmeanspp}
\caption{\kmpp}
	% Optionen
	\DontPrintSemicolon
	\SetKwInOut{Input}{Eingabe:}
	\SetKwInOut{Output}{Ausgabe:}
	
	% Input/Output
	\Input{$P \subseteq \Rd, k \in \mathbb{N}^{+}$}
	\Output{$k$ initiale Clusterzentren für $P$}
	\BlankLine
	
	% Algo
	Wähle $c_1$ zufällig gleichverteilt aus $P$\;
	\For{$i \leftarrow 1$ \KwTo $k$}{
		Wähle den Punkt $x' \in P \setminus \{ c_1, \dots, c_{i-1} \}$ als Zentrum $c_i$ mit Wahrscheinlichkeit $\frac{D(x')^2}{\sum_{x \in P} D(x)}$\;
	}
	Führe Lloyds Algorithmus mit den initialen Clusterzentren $c_1, \dots, c_k$ aus.
\end{algorithm}
Die $k$ Zentren, die von \kmpp{} ausgewählt werden, sind eine $\BigO{\log k}$-Approximation für das $k$-means-Problem, die durch
die anschließende Ausführung von Lloyds Algorithmus noch zu einem lokalen Optimum verbessert werden.
\absatz
Im nächsten Abschnitt betrachten wir eine konkrete Anwendung partitionierender Clusteringverfahren.

\subsection{Graphen und Clusteranalyse von Graphen}
\label{subsection:basics:graphs}

Gerade im Umgang mit großen Datenmengen hat sich in der Informatik der \emph{Graph} als geeignete Datenstruktur erwiesen. Er
ist wie folgt definiert.

\begin{definition}[Graph]
\label{def:graph}
	Sei $V$ eine endliche Menge und $E \subseteq \{ \{ u,v \} \mid u, v \in V, u \neq v \}$.
	Dann heißt das Tupel $G = (V, E)$ ein (endlicher) \emph{Graph} mit \emph{Knotenmenge} $V$ und
	\emph{Kantenmenge} $E$. Ist $e = \{ u,v \} \in E$, dann sagen wir, dass die Kante $e$ des Graphen $G$
	die Knoten $u$ und $v$ \emph{verbindet}. In diesem Fall sind $u$ und $v$ die \emph{Endknoten}
	von $e$.
	Ein Knoten $u \in V$ und eine Kante $e \in V$ heißen \emph{inzident}
	genau dann, wenn $u \in e$. Wir sagen, dass $u$ und ein weiterer Knoten $v \in V$ \emph{adjazent}
	sind genau dann, wenn es eine Kante $e' = \{ u,v \}$ in $E$ gibt.
	Typischerweise bezeichnet $n = \left|V\right|$ die \emph{Knotenzahl} von $G$ und
	$m = \left|E\right|$ die \emph{Kantenzahl} von $G$.
	
	Bei einem 3-Tupel $G' = (V', E', w')$ mit $w' : E \rightarrow \mathbb{N}$ spricht man von einem \emph{gewichteten} Graphen,
	dessen Kanten über ein Gewicht verfügen, das von der Gewichtsfunktion $w'$ abgebildet wird.
\end{definition}
Für die konkrete Datenhaltung von Graphen haben sich im Wesentlichen zwei Ansätze als praktikabel erwiesen: Bei den sogenannten
\emph{Adjazenzlisten} wird für jeden Knoten $v$ im Graphen eine Liste $Adj_v$ gehalten, in der für jeden zu $v$ inzidenten
Knoten ein Eintrag in $Adj_v$ enthalten ist, der den entsprechenden adjazenten Knoten referenziert, sowie gegebenenfalls das
Gewicht der Kante zwischen den beiden Knoten.
Alternativ wird in einer
\emph{Adjazenzmatrix} $Adj^G$ der Größe $\left|V\right| \times \left|V\right|$ an der Stelle $Adj^G_{u,v}$ das Gewicht der Kante
zwischen den Knoten $u$ und $v$ eingetragen, sofern die beiden Knoten durch eine Kante miteinander verbunden sind.
Anderenfalls wird zumeist $-1$ oder $0$ eingetragen. Bei ungewichteten Graphen wird dementsprechend lediglich $0$ oder $1$
eingetragen.
\absatz
Wenn die Eingabe keine Punktmenge, sondern ein (gewichteter) Graph ist, können wir die Ideen partitionierender Clusteringverfahren
übertragen. Wir interessieren uns in diesem Fall für die "`Ähnlichkeit"' von Knotenmengen im Graphen.

\begin{definition}[Graph-Schnitt]
	Sei $G=(V,E,w)$ ein gewichteter Graph. Ein \emph{Schnitt} $C=(S,T)$ von $G$ ist eine Partitionierung von $V$ in die beiden
	Mengen $S$ und $T$, das heißt, dass $V = S \cup T$. Die \emph{Schnittmenge} von $C$ sind die Kanten in $E$, die einen
	Endpunkt in $S$ und den anderen Endpunkt in $T$ haben, das heißt formal ist die Schnittmenge definiert als
	\[ \{ (u,v) \in E \mid u \in S, v \in T \}. \]
	Das Gewicht oder der Wert eines Schnittes ist die Summe der Kantengewichte der Schnittmenge. Wir verwenden die folgende
	Notation:
	\[ w_{cut}(S,T) = \sum_{u \in S, v \in T} w((u,v)) \]
	Falls der Graph in Form einer Adjazenzmatrix $Adj^G$ vorliegt, lautet die Berechnungsvorschrift entsprechend:
	\[ w_{cut}(S,T) = \sum_{u \in S, v \in T} Adj^G_{u,v} \]
\end{definition}
Für eine direkte Analogie zum $k$-means-Problem wäre ein Schnitt- beziehungsweise Paritionierungs-Begriff wünschenswert,
der eine $k$-fache Partitionierung der Knotenmenge erlaubt. Diese lautet wie folgt.

\begin{definition}[$k$-Graphpartitionierung]
	Sei $G=(V,E,w)$ ein gewichteter Graph. Für zwei Mengen $A, B \subseteq V$ definieren wir:
	\[ w(A,B) = \sum_{u \in A, v \in B} w((u,v)) \]
	Das $k$-Graphpartitionierungsproblem besteht darin, eine Partitionierung der Knotenmenge $V$ in $k$ disjunkte Teilmengen
	$V_1, \dots, V_k$ mit $\bigcup_{i \in \{1, \dots, k \}} V_i = V$ zu ermitteln, sodass sich die Knoten innerhalb einer
	Partition bezüglich einer Ähnlichkeitsrelation möglichst ähnlich sind und die Knoten unterschiedlicher Partitionen
	bezüglich der Ähnlichkeitsrelation möglichst stark voneinander unterscheiden.
	
	Beim Clustering von Punktmengen lagen für die Ähnlichkeitsrelation Metriken nahe, im Falle der Graphpartitionierung
	existiert eine Reihe von Optimierungskriterien, von denen wir im Folgenden die verbreitetsten einführen.
	
	\begin{enumerate}
		\item 	\textbf{Ratio Association}. Bei der Ratio Association sollen die Intra-Clusterabstände relativ zur jeweiligen
				Clustergröße maximiert werden:
				\[ \max_{V_1, \dots, V_k} \sum_{c=1}^{k} \frac{w(V_c, V_c)}{\left|V_c\right|} \]
		\item 	\textbf{Ratio Cut}. Beim Ratio Cut wird der Schnitt zwischen jeweils einem Cluster und allen anderen Punkten
				im Graphen minimiert:
				\[ \min_{V_1, \dots, V_k} \sum_{c=1}^{k} \frac{w(V_c, V \setminus V_c)}{\left|V_c\right|} \]
		\item 	\textbf{Kernighan-Lin}. Bei dem in~\cite{KernighanL70} vorgestellten Optimierungskriterium werden die
				Intra-Clusterabstände ähnlich der Ratio Association minimiert, allerdings müssen alle Partition hier zusätzlich
				die selbe Größe haben:
				\[ \min_{V_1, \dots, V_k} \sum_{c=1}^{k} \frac{w(V_c, V_c)}{\left|V_c\right|} \textrm{ subject to } 
				   \left|V_c\right| = \frac{\left|V\right|}{k} \, \forall \, c \in \{ 1, \dots, k \} \]
		\item 	\textbf{Normalized Cut}. Ziel des Normalized Cut ist wie beim Ratio Cut die Minimierung des Schnitts von einem
				Cluster mit den übrigen Punkten im Graphen, jedoch relativ 
		\item 	\textbf{}. 
		\item 	\textbf{}. 
	\end{enumerate}
\end{definition}

\subsection{Kernel-Methoden und spektrales Clustering}
\label{subsection:basics:kernel-spectral}